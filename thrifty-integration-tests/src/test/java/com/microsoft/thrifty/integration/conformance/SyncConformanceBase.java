/*
 * Thrifty
 *
 * Copyright (c) Microsoft Corporation
 *
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 * WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE,
 * FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.
 */
package com.microsoft.thrifty.integration.conformance;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.microsoft.thrifty.ThriftException;
import com.microsoft.thrifty.integration.gen.Insanity;
import com.microsoft.thrifty.integration.gen.Numberz;
import com.microsoft.thrifty.integration.gen.ThriftTestSyncClient;
import com.microsoft.thrifty.integration.gen.Xception;
import com.microsoft.thrifty.integration.gen.Xception2;
import com.microsoft.thrifty.integration.gen.Xtruct;
import com.microsoft.thrifty.integration.gen.Xtruct2;
import com.microsoft.thrifty.protocol.Protocol;
import com.microsoft.thrifty.testing.ServerProtocol;
import com.microsoft.thrifty.testing.ServerTransport;
import com.microsoft.thrifty.testing.TestServer;
import com.microsoft.thrifty.transport.SocketTransport;
import com.microsoft.thrifty.transport.Transport;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import okio.ByteString;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.junit.Assert.assertThat;

/**
 * A test of auto-generated service code for the standard ThriftTest
 * service.
 *
 * <p>Conformance is checked by roundtripping requests to a local server that
 * is run on the official Apache Thrift Java codebase.  The test server has
 * an implementation of ThriftTest methods with semantics as described in the
 * .thrift file itself and in the Apache Thrift git repo, along with Java code
 * generated by their compiler.
 */
public abstract class SyncConformanceBase {
    /**
     * An Apache Thrift server that is started anew for each test.
     *
     * <p>The server's transport and protocols are configured based
     * on values returned by the abstract methods
     * {@link #getServerProtocol()} and {@link #getServerTransport()}.
     */
    @Rule public TestServer testServer;

    private Transport transport;
    private Protocol protocol;
    private ThriftTestSyncClient client;

    public SyncConformanceBase() {
        ServerTransport serverTransport = getServerTransport();
        ServerProtocol serverProtocol = getServerProtocol();
        testServer = new TestServer(serverProtocol, serverTransport);
    }

    @Before
    public void setup() throws Exception {
        int port = testServer.port();
        SocketTransport transport = new SocketTransport.Builder("localhost", port)
                .readTimeout(2000)
                .build();

        transport.connect();

        this.transport = decorateTransport(transport);
        this.protocol = createProtocol(this.transport);
        this.client = new ThriftTestSyncClient(protocol);
    }

    /**
     * Specifies the kind of transport (blocking or non-blocking) for the
     * test server.
     */
    protected abstract ServerTransport getServerTransport();

    /**
     * Specifies which Thrift protocol the test server will use.
     */
    protected abstract ServerProtocol getServerProtocol();

    /**
     * When overridden in a derived class, wraps the given transport
     * in a decorator, e.g. a framed transport.
     */
    protected Transport decorateTransport(Transport transport) {
        return transport;
    }

    protected abstract Protocol createProtocol(Transport transport);

    @After
    public void teardown() throws Exception {
        if (client != null) {
            client.close();
            client = null;
        }

        if (protocol != null) {
            protocol.close();
            protocol = null;
        }

        if (transport != null) {
            transport.close();
            transport = null;
        }
    }

    @Test
    public void testVoid() throws Throwable {
        Object result = client.testVoid();

        assertThat(result, is(nullValue()));
    }

    @Test
    public void testBool() throws Throwable {
        Object result = client.testBool(Boolean.TRUE);

        assertThat(result, is(Boolean.TRUE));
    }

    @Test
    public void testByte() throws Throwable {
        Object result = client.testByte((byte) 200);

        assertThat(result, is((byte) 200));
    }

    @Test
    public void testI32() throws Throwable {
        Object result = client.testI32(404);

        assertThat(result, is(404));
    }

    @Test
    public void testI64() throws Throwable {
        Object result = client.testI64(Long.MAX_VALUE);

        assertThat(result, is(Long.MAX_VALUE));
    }

    @Test
    public void testDouble() throws Throwable {
        Object result = client.testDouble(Math.PI);

        assertThat(result, is(Math.PI));
    }

    @Test
    public void testBinary() throws Throwable {
        ByteString binary = ByteString.encodeUtf8("Peace on Earth and Thrift for all mankind");

        Object result = client.testBinary(binary);

        assertThat(result, equalTo(binary));
    }

    @Test
    public void testStruct() throws Throwable {
        Xtruct xtruct = new Xtruct.Builder()
                .byte_thing((byte) 1)
                .i32_thing(2)
                .i64_thing(3L)
                .string_thing("foo")
                .build();

        Object result = client.testStruct(xtruct);

        assertThat(result, equalTo(xtruct));
    }

    @Test
    public void testNest() throws Throwable {
        Xtruct xtruct = new Xtruct.Builder()
                .byte_thing((byte) 1)
                .i32_thing(2)
                .i64_thing(3L)
                .string_thing("foo")
                .build();

        Xtruct2 nest = new Xtruct2.Builder()
                .byte_thing((byte) 4)
                .i32_thing(5)
                .struct_thing(xtruct)
                .build();

        Object result = client.testNest(nest);

        assertThat(result, equalTo(nest));
    }

    @Test
    public void testMap() throws Throwable {
        Map<Integer, Integer> argument = new HashMap<>();
        argument.put(1, 2);
        argument.put(3, 4);
        argument.put(7, 8);

        Object result = client.testMap(argument);

        assertThat(result, equalTo(argument));
    }

    @Test
    public void testStringMap() throws Throwable {
        Map<String, String> argument = new HashMap<>();
        argument.put("foo", "bar");
        argument.put("baz", "quux");
        argument.put("one", "more");

        Object result = client.testStringMap(argument);

        assertThat(result, equalTo(argument));
    }

    @Test
    public void testSet() throws Throwable {
        Set<Integer> set = new LinkedHashSet<>();
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(4);
        set.add(5);

        Object result = client.testSet(set);

        assertThat(result, equalTo(set));
    }

    @Test
    public void testList() throws Throwable {
        List<Integer> list = Arrays.asList(10, 9, 8, 7, 6, 5, 4, 3, 2, 1);

        Object result = client.testList(list);

        assertThat(result, equalTo(list));
    }

    @Test
    public void testEnum() throws Throwable {
        Numberz argument = Numberz.EIGHT;

        Object result = client.testEnum(argument);

        assertThat(result, equalTo(Numberz.EIGHT));
    }

    @Test
    public void testTypedef() throws Throwable {
        Object result = client.testTypedef(Long.MIN_VALUE);

        assertThat(result, equalTo(Long.MIN_VALUE));
    }

    @Test
    public void testMapMap() throws Throwable {
        Object result = client.testMapMap(Integer.MAX_VALUE);

        Map<Integer, Map<Integer, Integer>> expected = ImmutableMap.<Integer, Map<Integer, Integer>>builder()
                .put(-4, ImmutableMap.<Integer, Integer>builder()
                        .put(-4, -4)
                        .put(-3, -3)
                        .put(-2, -2)
                        .put(-1, -1)
                        .build())
                .put(4, ImmutableMap.<Integer, Integer>builder()
                        .put(1, 1)
                        .put(2, 2)
                        .put(3, 3)
                        .put(4, 4)
                        .build())
                .build();

        assertThat(result, equalTo(expected));
    }

    @Test
    public void testInsanity() throws Throwable {
        Insanity empty = new Insanity.Builder().build();
        Insanity argument = new Insanity.Builder()
                .userMap(ImmutableMap.of(Numberz.ONE, 10L, Numberz.TWO, 20L, Numberz.THREE, 40L))
                .xtructs(ImmutableList.of(new Xtruct.Builder()
                        .byte_thing((byte) 18)
                        .i32_thing(37)
                        .i64_thing(101L)
                        .string_thing("what")
                        .build()))
                .build();

        Map<Long, Map<Numberz, Insanity>> expected = ImmutableMap.<Long, Map<Numberz, Insanity>>builder()
                .put(1L, ImmutableMap.of(Numberz.TWO, argument, Numberz.THREE, argument))
                .put(2L, ImmutableMap.of(Numberz.SIX, empty))
                .build();

        Object result = client.testInsanity(argument);

        assertThat(result, equalTo(expected));
    }

    @Test
    public void testMulti() throws Throwable {
        Xtruct expected = new Xtruct.Builder()
                .string_thing("Hello2")
                .byte_thing((byte) 9)
                .i32_thing(11)
                .i64_thing(13L)
                .build();

        Object result = client.testMulti((byte) 9, 11, 13L, ImmutableMap.of((short) 10, "Hello"), Numberz.THREE, 5L);

        assertThat(result, equalTo(expected));
    }

    @Test
    public void testExceptionNormalError() throws Throwable {
        try {
            client.testException("Xception");
            throw  new AssertionError("Should never be reached");
        } catch (Throwable error) {
            assertThat(error, instanceOf(Xception.class));

            Xception e = (Xception) error;
            assertThat(e.errorCode, equalTo(1001));
            assertThat(e.message, equalTo("Xception"));
        }
    }

    @Test
    public void testExceptionInternalError() throws Throwable {
        try {
            client.testException("TException");
            throw  new AssertionError("Should never be reached");
        } catch (Throwable error) {
            assertThat(error, instanceOf(ThriftException.class));

            ThriftException e = (ThriftException) error;
            assertThat(e.kind, is(ThriftException.Kind.INTERNAL_ERROR));
        }
    }

    @Test
    public void testMultiExceptionNoError() throws Throwable {
        Xtruct actual = client.testMultiException("Normal", "Hi there");

        // Note: We aren't asserting against an expected value because the members
        //       of the result are unspecified besides 'string_thing', and Thrift
        //       implementations differ on whether to return unset primitive values,
        //       depending on options set during codegen.
        assertThat(actual.string_thing, equalTo("Hi there"));
    }

    @Test
    public void testMultiExceptionErrorOne() throws Throwable {
        try {
            client.testMultiException("Xception", "nope");
        } catch (Throwable error) {
            Throwable expected = new Xception.Builder()
                    .errorCode(1001)
                    .message("This is an Xception")
                    .build();

            assertThat(error, equalTo(expected));
        }
    }

    @Test
    public void testMultiExceptionErrorTwo() throws Throwable {
        try {
            client.testMultiException("Xception2", "nope");
        } catch (Xception2 error) {
            // Note: We aren't asserting against an expected value because the members
            //       of 'struct_thing' are unspecified besides 'string_thing', and Thrift
            //       implementations differ on whether to return unset primitive values,
            //       depending on options set during codegen.
            assertThat(error.errorCode, equalTo(2002));
            assertThat(error.struct_thing.string_thing, equalTo("This is an Xception2"));
        }
    }

}
