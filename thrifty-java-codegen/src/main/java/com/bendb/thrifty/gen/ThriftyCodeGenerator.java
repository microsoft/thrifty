package com.bendb.thrifty.gen;

import com.bendb.thrifty.Adapter;
import com.bendb.thrifty.StructBuilder;
import com.bendb.thrifty.TType;
import com.bendb.thrifty.ThriftField;
import com.bendb.thrifty.protocol.FieldMetadata;
import com.bendb.thrifty.protocol.ListMetadata;
import com.bendb.thrifty.protocol.MapMetadata;
import com.bendb.thrifty.protocol.SetMetadata;
import com.bendb.thrifty.protocol.Protocol;
import com.bendb.thrifty.schema.Constant;
import com.bendb.thrifty.schema.EnumType;
import com.bendb.thrifty.schema.Field;
import com.bendb.thrifty.schema.Location;
import com.bendb.thrifty.schema.Named;
import com.bendb.thrifty.schema.NamespaceScope;
import com.bendb.thrifty.schema.Schema;
import com.bendb.thrifty.schema.StructType;
import com.bendb.thrifty.schema.ThriftType;
import com.bendb.thrifty.schema.parser.ConstValueElement;
import com.bendb.thrifty.util.ProtocolUtil;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Strings;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Multimap;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.NameAllocator;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import okio.ByteString;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

import javax.annotation.Generated;
import javax.annotation.Nullable;
import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.IOException;
import java.net.ProtocolException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

public final class ThriftyCodeGenerator {
    private static final String FILE_COMMENT = "Automatically generated by the Thrifty compiler; do not edit!";

    public static final String ADAPTER_FIELDNAME = "ADAPTER";

    private static final DateTimeFormatter DATE_FORMATTER =
            ISODateTimeFormat.dateTime().withZoneUTC();

    static final TypeName BOOLEAN = ClassName.BOOLEAN.box();
    static final TypeName BYTE = ClassName.BYTE.box();
    static final TypeName SHORT = ClassName.SHORT.box();
    static final TypeName INTEGER = ClassName.INT.box();
    static final TypeName LONG = ClassName.LONG.box();
    static final TypeName DOUBLE = ClassName.DOUBLE.box();
    static final TypeName VOID = ClassName.VOID; // Don't box void, it is only used as a non-return-value.

    static final ClassName COLLECTIONS = ClassName.get(Collections.class);
    static final ClassName STRING = ClassName.get(String.class);
    static final ClassName LIST = ClassName.get(List.class);
    static final ClassName MAP = ClassName.get(Map.class);
    static final ClassName MAP_ENTRY = ClassName.get(Map.Entry.class);
    static final ClassName SET = ClassName.get(Set.class);
    static final ClassName BYTE_STRING = ClassName.get(ByteString.class);
    static final ClassName STRING_BUILDER = ClassName.get(StringBuilder.class);

    static final ClassName LIST_META = ClassName.get(ListMetadata.class);
    static final ClassName SET_META = ClassName.get(SetMetadata.class);
    static final ClassName MAP_META = ClassName.get(MapMetadata.class);

    static final ClassName PROTOCOL = ClassName.get(Protocol.class);
    static final ClassName PROTO_UTIL = ClassName.get(ProtocolUtil.class);
    static final ClassName PROTOCOL_EXCEPTION = ClassName.get(ProtocolException.class);
    static final ClassName TTYPE = ClassName.get(TType.class);

    static final ClassName BUILDER = ClassName.get(StructBuilder.class);
    static final ClassName ADAPTER = ClassName.get(Adapter.class);

    static final ClassName FIELD_METADATA = ClassName.get(FieldMetadata.class);

    /**
     * A mapping of {@link TType} constant values to their Java names.
     */
    static final ImmutableMap<Byte, String> TTYPE_NAMES;

    static {
        ImmutableMap.Builder<Byte, String> map = ImmutableMap.builder();
        map.put(TType.BOOL, "BOOL");
        map.put(TType.BYTE, "BYTE");
        map.put(TType.I16, "I16");
        map.put(TType.I32, "I32");
        map.put(TType.I64, "I64");
        map.put(TType.DOUBLE, "DOUBLE");
        map.put(TType.STRING, "STRING");
        map.put(TType.ENUM, "ENUM");
        map.put(TType.STRUCT, "STRUCT");
        map.put(TType.LIST, "LIST");
        map.put(TType.SET, "SET");
        map.put(TType.MAP, "MAP");
        map.put(TType.VOID, "VOID");
        map.put(TType.STOP, "STOP");
        TTYPE_NAMES = map.build();
    }

    private final Map<String, ClassName> nameCache = new LinkedHashMap<>();
    private final Schema schema;
    private final ClassName listClassName;
    private final ClassName setClassName;
    private final ClassName mapClassName;

    public ThriftyCodeGenerator(Schema schema) {
        this(
                schema,
                ClassName.get(ArrayList.class),
                ClassName.get(HashSet.class),
                ClassName.get(HashMap.class));
    }

    private ThriftyCodeGenerator(
            Schema schema,
            ClassName listClassName,
            ClassName setClassName,
            ClassName mapClassName) {
        this.schema = schema;
        this.listClassName = Preconditions.checkNotNull(listClassName);
        this.setClassName = Preconditions.checkNotNull(setClassName);
        this.mapClassName = Preconditions.checkNotNull(mapClassName);
    }

    public ThriftyCodeGenerator withListType(String listClassName) {
        return new ThriftyCodeGenerator(
                schema,
                ClassName.bestGuess(listClassName),
                setClassName,
                mapClassName);
    }

    public ThriftyCodeGenerator withSetType(String setClassName) {
        return new ThriftyCodeGenerator(
                schema,
                listClassName,
                ClassName.bestGuess(setClassName),
                mapClassName);
    }

    public ThriftyCodeGenerator withMapType(String mapClassName) {
        return new ThriftyCodeGenerator(
                schema,
                listClassName,
                setClassName,
                ClassName.bestGuess(mapClassName));
    }

    public void generate(final File directory) throws IOException {
        generate(new FileWriter() {
            @Override
            public void write(JavaFile file) throws IOException {
                file.writeTo(directory);
            }
        });
    }

    public void generate(final Appendable appendable) throws IOException {
        generate(new FileWriter() {
            @Override
            public void write(JavaFile file) throws IOException {
                file.writeTo(appendable);
            }
        });
    }

    private interface FileWriter {
        void write(JavaFile file) throws IOException;
    }

    private void generate(FileWriter writer) throws IOException {
        for (EnumType type : schema.enums()) {
            TypeSpec spec = buildEnum(type);
            JavaFile file = assembleJavaFile(type, spec);
            writer.write(file);
        }

        for (StructType struct : schema.structs()) {
            TypeSpec spec = buildStruct(struct);
            JavaFile file = assembleJavaFile(struct, spec);
            writer.write(file);
        }

        for (StructType exception : schema.exceptions()) {
            TypeSpec spec = buildStruct(exception);
            JavaFile file = assembleJavaFile(exception, spec);
            writer.write(file);
        }

        for (StructType union : schema.unions()) {
            TypeSpec spec = buildStruct(union);
            JavaFile file = assembleJavaFile(union, spec);
            writer.write(file);
        }

        Multimap<String, Constant> constantsByPackage = HashMultimap.create();
        for (Constant constant : schema.constants()) {
            constantsByPackage.put(constant.getNamespaceFor(NamespaceScope.JAVA), constant);
        }

        for (Map.Entry<String, Collection<Constant>> entry : constantsByPackage.asMap().entrySet()) {
            String packageName = entry.getKey();
            Collection<Constant> values = entry.getValue();
            TypeSpec spec = buildConst(packageName, values);
            JavaFile file = assembleJavaFile(packageName, spec);
            writer.write(file);
        }
        // TODO: Services, constants
    }

    private JavaFile assembleJavaFile(Named named, TypeSpec spec) {
        String packageName = named.getNamespaceFor(NamespaceScope.JAVA);
        if (Strings.isNullOrEmpty(packageName)) {
            throw new IllegalArgumentException("A Java package name must be given for java code generation");
        }

        return assembleJavaFile(packageName, spec, named.location());
    }

    private JavaFile assembleJavaFile(String packageName, TypeSpec spec) {
        return assembleJavaFile(packageName, spec, null);
    }

    private JavaFile assembleJavaFile(String packageName, TypeSpec spec, Location location) {
        JavaFile.Builder file = JavaFile.builder(packageName, spec)
                .skipJavaLangImports(true)
                .addFileComment(FILE_COMMENT);

        if (location != null) {
            file.addFileComment("\nSource: $L", location);
        }

        return file.build();
    }

    TypeSpec buildStruct(StructType type) {
        String packageName = type.getNamespaceFor(NamespaceScope.JAVA);
        ClassName structTypeName = ClassName.get(packageName, type.name());
        ClassName builderTypeName = structTypeName.nestedClass("Builder");
        TypeName adapterSuperclass = ParameterizedTypeName.get(ADAPTER, structTypeName, builderTypeName);

        TypeSpec.Builder structBuilder = TypeSpec.classBuilder(type.name())
                .addAnnotation(generatedAnnotation())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

        if (type.hasJavadoc()) {
            structBuilder.addJavadoc(type.documentation());
        }

        if (type.isException()) {
            structBuilder.superclass(Exception.class);
        }

        TypeSpec builderSpec = builderFor(type, structTypeName, builderTypeName);
        TypeSpec adapterSpec = adapterFor(type, structTypeName, builderTypeName);

        structBuilder.addType(builderSpec);
        structBuilder.addField(FieldSpec.builder(adapterSuperclass, ADAPTER_FIELDNAME)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("$L", adapterSpec)
                .build());

        MethodSpec.Builder ctor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .addParameter(builderTypeName, "builder");

        for (Field field : type.fields()) {
            String name = field.name();
            ThriftType fieldType = field.type();
            ThriftType trueType = fieldType.getTrueType();
            TypeName fieldTypeName = getJavaClassName(trueType);

            // Define field
            FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldTypeName, name)
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .addAnnotation(fieldAnnotation(field));

            if (field.hasJavadoc()) {
                fieldBuilder = fieldBuilder.addJavadoc(field.documentation());
            }

            structBuilder.addField(fieldBuilder.build());

            // Update the struct ctor
            if (trueType.isList()) {
                ctor.addStatement("this.$N = $T.unmodifiableList(builder.$N)",
                        name, COLLECTIONS, name);
            } else if (trueType.isSet()) {
                ctor.addStatement("this.$N = $T.unmodifiableSet(builder.$N)",
                        name, COLLECTIONS, name);
            } else if (trueType.isMap()) {
                ctor.addStatement("this.$N = $T.unmodifiableMap(builder.$N)",
                        name, COLLECTIONS, name);
            } else {
                ctor.addStatement("this.$N = builder.$N", name, name);
            }
        }

        structBuilder.addMethod(ctor.build());
        structBuilder.addMethod(buildEqualsFor(type));
        structBuilder.addMethod(buildHashCodeFor(type));
        structBuilder.addMethod(buildToStringFor(type));

        return structBuilder.build();
    }

    private TypeSpec builderFor(
            StructType structType,
            ClassName structClassName,
            ClassName builderClassName) {
        TypeName builderSuperclassName = ParameterizedTypeName.get(BUILDER, structClassName);
        TypeSpec.Builder builder = TypeSpec.classBuilder("Builder")
                .addSuperinterface(builderSuperclassName)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);

        MethodSpec.Builder buildMethodBuilder = MethodSpec.methodBuilder("build")
                .addAnnotation(Override.class)
                .returns(structClassName)
                .addModifiers(Modifier.PUBLIC);

        MethodSpec.Builder resetBuilder = MethodSpec.methodBuilder("reset")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC);

        MethodSpec.Builder copyCtor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(structClassName, "struct");

        MethodSpec.Builder defaultCtor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC);

        if (structType.isUnion()) {
            buildMethodBuilder.addStatement("int setFields = 0");
        }

        // Add fields to the struct and set them in the ctor
        NameAllocator allocator = new NameAllocator();
        for (Field field : structType.fields()) {
            allocator.newName(field.name(), field.name());
        }

        for (Field field : structType.fields()) {
            TypeName javaTypeName = getJavaClassName(field.type());
            String fieldName = field.name();
            FieldSpec.Builder f = FieldSpec.builder(javaTypeName, fieldName, Modifier.PRIVATE);

            if (field.hasJavadoc()) {
                f.addJavadoc(field.documentation());
            }

            if (field.defaultValue() != null) {
                CodeBlock.Builder initializer = CodeBlock.builder();
                generateFieldInitializer(
                        initializer,
                        allocator,
                        "this." + field.name(),
                        field.type().getTrueType(),
                        field.defaultValue());
                defaultCtor.addCode(initializer.build());

                resetBuilder.addCode(initializer.build());
            } else {
                resetBuilder.addStatement("this.$N = null", fieldName);
            }

            builder.addField(f.build());

            MethodSpec setter = MethodSpec.methodBuilder(fieldName)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(builderClassName)
                    .addParameter(javaTypeName, fieldName)
                    .addStatement("this.$N = $N", fieldName, fieldName)
                    .addStatement("return this")
                    .build();

            builder.addMethod(setter);

            if (structType.isUnion()) {
                buildMethodBuilder
                        .addStatement("if (this.$N != null) ++setFields", fieldName);
            } else {
                if (field.required()) {
                    buildMethodBuilder.beginControlFlow("if (this.$N == null)", fieldName);
                    buildMethodBuilder.addStatement(
                            "throw new $T($S)",
                            PROTOCOL_EXCEPTION,
                            "Required field '" + fieldName + "' is missing");
                    buildMethodBuilder.endControlFlow();
                }
            }

            copyCtor.addStatement("this.$N = $N.$N", fieldName, "struct", fieldName);
        }

        if (structType.isUnion()) {
            buildMethodBuilder
                    .beginControlFlow("if (setFields != 1)")
                    .addStatement(
                            "throw new $T($S + setFields + $S)",
                            PROTOCOL_EXCEPTION,
                            "Invalid union; ",
                            " field(s) were set")
                    .endControlFlow();
        }

        buildMethodBuilder.addStatement("return new $T(this)", structClassName);
        builder.addMethod(defaultCtor.build());
        builder.addMethod(copyCtor.build());
        builder.addMethod(buildMethodBuilder.build());
        builder.addMethod(resetBuilder.build());

        return builder.build();
    }

    private MethodSpec buildEqualsFor(StructType struct) {
        MethodSpec.Builder equals = MethodSpec.methodBuilder("equals")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(boolean.class)
                .addParameter(Object.class, "other")
                .addStatement("if (this == other) return true")
                .addStatement("if (other == null) return false");


        if (struct.fields().size() > 0) {
            equals.addStatement("if (getType() != other.getType()) return false")
                    .addStatement("$1L that = ($1L) other", struct.name());
        }

        boolean isFirst = true;
        for (Field field : struct.fields()) {
            if (isFirst) {
                equals.addCode("$[return (this.$1N == that.$1N || (this.$1N != null && this.$1N.equals(that.$1N)))",
                        field.name());
                isFirst = false;
            } else {
                equals.addCode("\n&& (this.$1N == that.$1N || (this.$1N != null && this.$1N.equals(that.$1N)))",
                        field.name());
            }
        }

        if (struct.fields().size() > 0) {
            equals.addCode(";\n$]");
        } else {
            equals.addStatement("return that instanceof $L", struct.name());
        }

        return equals.build();
    }

    private MethodSpec buildHashCodeFor(StructType struct) {
        MethodSpec.Builder hashCode = MethodSpec.methodBuilder("hashCode")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(int.class)
                .addStatement("int code = 16777619");

        for (Field field : struct.fields()) {
            hashCode.addStatement("code ^= (this.$1N == null) ? 0 : this.$1N.hashCode()", field.name());
            hashCode.addStatement("code *= 0x811c9dc5");
        }

        hashCode.addStatement("return code");
        return hashCode.build();
    }

    private MethodSpec buildToStringFor(StructType struct) {
        MethodSpec.Builder toString = MethodSpec.methodBuilder("toString")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class);

        if (struct.fields().size() > 0) {
            toString.addStatement("$1T sb = new $1T()", STRING_BUILDER);
            toString.addStatement("sb.append($S).append(\"{\\n  \")", struct.name());

            int index = 0;
            for (Field field : struct.fields()) {
                boolean isLast = ++index == struct.fields().size();
                toString.addStatement("sb.append($S)", field.name() + "=");
                toString.addStatement("sb.append(this.$1N == null ? \"null\" : this.$1N)", field.name());
                if (isLast) {
                    toString.addStatement("sb.append(\"\\n}\")");
                } else {
                    toString.addStatement("sb.append(\",\\n  \")");
                }
            }

            toString.addStatement("return sb.toString()");
        } else {
            toString.addStatement("return $S", struct.name() + "{}");
        }

        return toString.build();
    }

    TypeSpec buildConst(String packageName, Collection<Constant> constants) {
        throw new IllegalStateException("not implemented");
    }

    @SuppressWarnings("unchecked")
    private void generateFieldInitializer(
            final CodeBlock.Builder initializer,
            final NameAllocator allocator,
            final String name,
            final ThriftType tt,
            final ConstValueElement value) {

        tt.getTrueType().accept(new SimpleVisitor<Void>() {
            @Override
            public Void visitBuiltin(ThriftType builtinType) {
                CodeBlock init = renderConstValue(initializer, allocator, tt, value);
                initializer.addStatement("$L = $L", name, init);
                return null;
            }

            @Override
            public Void visitEnum(ThriftType userType) {
                CodeBlock item = renderConstValue(initializer, allocator, tt, value);

                initializer.addStatement("$L = $L", name, item);
                return null;
            }

            @Override
            public Void visitList(ThriftType.ListType listType) {
                List<ConstValueElement> list = (List<ConstValueElement>) value.value();
                String listName = allocator.newName("list", "list");
                TypeName elementTypeName = getJavaClassName(listType.elementType());
                initializer.addStatement("$T $N = new $T($L)",
                        ParameterizedTypeName.get(LIST, elementTypeName),
                        listName,
                        ParameterizedTypeName.get(listClassName, elementTypeName),
                        list.size());

                for (ConstValueElement element : list) {
                    CodeBlock item = renderConstValue(
                            initializer,
                            allocator,
                            listType.elementType().getTrueType(),
                            element);
                    initializer.addStatement("$N.add($L)", listName, item);
                }

                initializer.addStatement("$N = $N", name, listName);
                return null;
            }

            @Override
            public Void visitSet(ThriftType.SetType setType) {
                List<ConstValueElement> set = (List<ConstValueElement>) value.value();
                String setName = allocator.newName("set", "set");
                TypeName elementTypeName = getJavaClassName(setType.elementType());
                initializer.addStatement("$T $N = new $T($L)",
                        ParameterizedTypeName.get(SET, elementTypeName),
                        setName,
                        ParameterizedTypeName.get(setClassName, elementTypeName),
                        set.size());

                for (ConstValueElement element : set) {
                    CodeBlock item = renderConstValue(
                            initializer,
                            allocator,
                            setType.elementType().getTrueType(),
                            element);
                    initializer.addStatement("$N.add($L)", setName, item);
                }

                initializer.addStatement("$N = $N", name, setName);
                return null;
            }

            @Override
            public Void visitMap(ThriftType.MapType mapType) {
                return null;
            }

            @Override
            public Void visitUserType(ThriftType userType) {
                // TODO: this
                throw new UnsupportedOperationException("struct-type default values are not yet implemented");
            }

            @Override
            public Void visitTypedef(ThriftType.TypedefType typedefType) {
                throw new AssertionError("Should not be possible!");
            }
        });
    }

    private CodeBlock renderConstValue(
            final CodeBlock.Builder block,
            final NameAllocator allocator,
            final ThriftType type,
            final ConstValueElement value) {
        // TODO: Emit references to constants if kind == IDENTIFIER and it identifies an appropriately-typed const
        return type.accept(new ThriftType.Visitor<CodeBlock>() {
            @Override
            public CodeBlock visitBool() {
                String name;
                if (value.kind() == ConstValueElement.Kind.IDENTIFIER) {
                    name = "true".equals(value.value()) ? "true" : "false";
                } else if (value.kind() == ConstValueElement.Kind.INTEGER) {
                    name = ((Long) value.value()) == 0L ? "false" : "true";
                } else {
                    throw new AssertionError("Invalid boolean constant: " + value.value());
                }

                return CodeBlock.builder().add(name).build();
            }

            @Override
            public CodeBlock visitByte() {
                return castInt("byte", ThriftType.BYTE, value);
            }

            @Override
            public CodeBlock visitI16() {
                return castInt("short", ThriftType.I16, value);
            }

            @Override
            public CodeBlock visitI32() {
                return castInt("int", ThriftType.I32, value);
            }

            @Override
            public CodeBlock visitI64() {
                return castInt("long", ThriftType.I64, value);
            }

            @Override
            public CodeBlock visitDouble() {
                if (value.kind() == ConstValueElement.Kind.DOUBLE) {
                    return CodeBlock.builder().add("(double) $L", value.getAsDouble()).build();
                } else {
                    throw new AssertionError("Invalid double constant: " + value.value());
                }
            }

            private CodeBlock castInt(String name, ThriftType type, ConstValueElement value) {
                if (value.kind() == ConstValueElement.Kind.INTEGER) {
                    return CodeBlock.builder().add("($L) $L", name, value.getAsLong()).build();
                } else {
                    throw new AssertionError("Invalid " + type.name() + " constant: " + value.value());
                }
            }

            @Override
            public CodeBlock visitString() {
                if (value.kind() == ConstValueElement.Kind.STRING) {
                    return CodeBlock.builder().add("$S", value.value()).build();
                } else {
                    throw new AssertionError("Invalid string constant: " + value.value());
                }
            }

            @Override
            public CodeBlock visitBinary() {
                throw new AssertionError("Binary literals are not supported");
            }

            @Override
            public CodeBlock visitVoid() {
                throw new AssertionError("Void literals are meaningless, what are you even doing");
            }

            @Override
            public CodeBlock visitEnum(final ThriftType tt) {
                EnumType e;
                try {
                    e = Iterables.find(schema.enums(), new Predicate<EnumType>() {
                        @Override
                        public boolean apply(@Nullable EnumType enumType) {
                            return enumType != null && enumType.type().equals(tt);
                        }
                    });
                } catch (NoSuchElementException ignored) {
                    throw new AssertionError("Missing enum type: " + tt.name());
                }

                Predicate<EnumType.Member> predicate;
                if (value.kind() == ConstValueElement.Kind.INTEGER) {
                    final int intValue = ((Long) value.value()).intValue();
                    predicate = new Predicate<EnumType.Member>() {
                        @Override
                        public boolean apply(@Nullable EnumType.Member member) {
                            return member != null && member.value() == intValue;
                        }
                    };
                } else if (value.kind() == ConstValueElement.Kind.IDENTIFIER) {
                    final String memberName = (String) value.value();
                    predicate = new Predicate<EnumType.Member>() {
                        @Override
                        public boolean apply(@Nullable EnumType.Member member) {
                            return member != null && member.name().equals(memberName);
                        }
                    };
                } else {
                    throw new AssertionError(
                            "Constant value kind " + value.kind() + " is not possibly and enum; validation bug");
                }

                EnumType.Member member;
                try {
                    member = Iterables.find(e.members(), predicate);
                } catch (NoSuchElementException ignored) {
                    throw new IllegalStateException("No enum member in " + e.name() + " with value " + value.value());
                }

                return CodeBlock.builder()
                        .add("$T.$L", getJavaClassName(tt), member.name())
                        .build();
            }

            @Override
            public CodeBlock visitList(ThriftType.ListType listType) {
                throw new IllegalStateException("nested lists not implemented");
            }

            @Override
            public CodeBlock visitSet(ThriftType.SetType setType) {
                throw new IllegalStateException("nested sets not implemented");
            }

            @Override
            public CodeBlock visitMap(ThriftType.MapType mapType) {
                throw new IllegalStateException("nested maps not implemented");
            }

            @Override
            public CodeBlock visitUserType(ThriftType userType) {
                throw new IllegalStateException("nested structs not implemented");
            }

            @Override
            public CodeBlock visitTypedef(ThriftType.TypedefType typedefType) {
                return null;
            }
        });
    }

    private TypeSpec adapterFor(StructType structType, ClassName structClassName, ClassName builderClassName) {
        TypeName adapterSuperclass = ParameterizedTypeName.get(ADAPTER, structClassName, builderClassName);

        final MethodSpec.Builder write = MethodSpec.methodBuilder("write")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(PROTOCOL, "protocol")
                .addParameter(structClassName, "struct")
                .addException(IOException.class);

        final MethodSpec.Builder read = MethodSpec.methodBuilder("read")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(getJavaClassName(structType.type()))
                .addParameter(PROTOCOL, "protocol")
                .addParameter(builderClassName, "builder")
                .addException(IOException.class);

        final MethodSpec readHelper = MethodSpec.methodBuilder("read")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(getJavaClassName(structType.type()))
                .addParameter(PROTOCOL, "protocol")
                .addException(IOException.class)
                .addStatement("return read(protocol, new $T())", builderClassName)
                .build();

        // First, the writer
        write.addStatement("protocol.writeStructBegin($S)", structType.name());

        // Then, the reader - set up the field-reading loop.
        read.addStatement("protocol.readStructBegin()");
        read.beginControlFlow("while (true)");
        read.addStatement("$T field = protocol.readFieldBegin()", FIELD_METADATA);
        read.beginControlFlow("if (field.fieldId == $T.STOP)", TTYPE);
        read.addStatement("break");
        read.endControlFlow();

        if (structType.fields().size() > 0) {
            read.beginControlFlow("switch (field.fieldId)");
        }

        for (Field field : structType.fields()) {
            boolean optional = !field.required();
            final String name = field.name();
            final ThriftType tt = field.type().getTrueType();
            byte typeCode = typeCode(tt);
            String typeCodeName = TTYPE_NAMES.get(typeCode);

            // Write
            if (optional) {
                write.beginControlFlow("if (struct.$N != null)", name);
            }

            write.addStatement("protocol.writeFieldBegin($S, $L, $T.$L)", name,  field.id(), TTYPE, typeCodeName);

            tt.accept(new GenerateWriterVisitor(write, "protocol", "struct", field));

            write.addStatement("protocol.writeFieldEnd()");

            if (optional) {
                write.endControlFlow();
            }

            // Read
            read.beginControlFlow("case $L:", field.id());
            new GenerateReaderVisitor(read, field).generate();
            read.endControlFlow(); // end case block
            read.addStatement("break");

        }

        write.addStatement("protocol.writeFieldStop()");
        write.addStatement("protocol.writeStructEnd()");

        if (structType.fields().size() > 0) {
            read.endControlFlow(); //
        }

        read.addStatement("protocol.readFieldEnd()");
        read.endControlFlow(); // end while
        read.addStatement("return builder.build()");

        return TypeSpec.anonymousClassBuilder("")
                .superclass(adapterSuperclass)
                .addMethod(write.build())
                .addMethod(read.build())
                .addMethod(readHelper)
                .build();
    }

    private static AnnotationSpec fieldAnnotation(Field field) {
        AnnotationSpec.Builder ann = AnnotationSpec.builder(ThriftField.class)
                .addMember("fieldId", "$L", field.id())
                .addMember("isRequired", "$L", field.required());

        String typedef = field.typedefName();
        if (!Strings.isNullOrEmpty(typedef)) {
            ann = ann.addMember("typedefName", "$S", typedef);
        }

        return ann.build();
    }

    private static AnnotationSpec generatedAnnotation() {
        return AnnotationSpec.builder(Generated.class)
                .addMember("value", "$S", ThriftyCodeGenerator.class.getCanonicalName())
                .addMember("date", "$S", DATE_FORMATTER.print(System.currentTimeMillis()))
                .build();
    }

    TypeSpec buildEnum(EnumType type) {
        ClassName enumClassName = ClassName.get(
                type.getNamespaceFor(NamespaceScope.JAVA),
                type.name());

        TypeSpec.Builder builder = TypeSpec.enumBuilder(type.name())
                .addAnnotation(generatedAnnotation())
                .addModifiers(Modifier.PUBLIC)
                .addField(int.class, "code", Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(MethodSpec.constructorBuilder()
                        .addParameter(int.class, "code")
                        .addStatement("this.$N = $N", "code", "code")
                        .build());

        if (type.hasJavadoc()) {
            builder.addJavadoc(type.documentation());
        }

        MethodSpec.Builder fromCodeMethod = MethodSpec.methodBuilder("fromCode")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(enumClassName)
                .addParameter(int.class, "code")
                .beginControlFlow("switch (code)");

        for (EnumType.Member member : type.members()) {
            String name = member.name();

            int value = member.value();

            TypeSpec.Builder memberBuilder = TypeSpec.anonymousClassBuilder("$L", value);
            if (member.hasJavadoc()) {
                memberBuilder.addJavadoc(member.documentation());
            }

            builder.addEnumConstant(name, memberBuilder.build());

            fromCodeMethod.addStatement("case $L: return $N", value, name);
        }

        fromCodeMethod
                .addStatement("default: return null")
                .endControlFlow();

        builder.addMethod(fromCodeMethod.build());

        return builder.build();
    }

    private TypeName getJavaClassName(ThriftType type) {
        return type.getTrueType().accept(typeNameVisitor);
    }

    private byte typeCode(ThriftType type) {
        return type.getTrueType().accept(TYPE_CODE_VISITOR);
    }

    /**
     * Generates Java code to write the value of a field in a {@link Adapter#write}
     * implementation.
     *
     * Handles nested values like lists, sets, maps, and user types.
     */
    class GenerateWriterVisitor implements ThriftType.Visitor<Void> {
        private MethodSpec.Builder write;
        private String proto;
        private Deque<String> nameStack = new LinkedList<>();
        private NameAllocator nameAllocator;
        private int scopeLevel;

        GenerateWriterVisitor(
                MethodSpec.Builder write,
                String proto,
                String subject,
                Field field) {
            this.write = write;
            this.proto = proto;
            nameStack.push(subject + "." + field.name());
        }

        public Void visitBool() {
            write.addStatement("$N.writeBool($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitByte() {
            write.addStatement("$N.writeByte($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI16() {
            write.addStatement("$N.writeI16($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI32() {
            write.addStatement("$N.writeI32($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI64() {
            write.addStatement("$N.writeI64($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitDouble() {
            write.addStatement("$N.writeDouble($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitString() {
            write.addStatement("$N.writeString($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitBinary() {
            write.addStatement("$N.writeBinary($L)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitVoid() {
            throw new AssertionError("Fields cannot be void");
        }

        @Override
        public Void visitEnum(ThriftType userType) {
            write.addStatement("$N.writeI32($L.code)", proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitList(ThriftType.ListType listType) {
            initCollectionHelpers();
            String tag = "item" + scopeLevel;
            String item = nameAllocator.newName(tag, tag);

            ThriftType tt = listType.elementType().getTrueType();
            byte typeCode = typeCode(tt);
            String typeCodeName = TTYPE_NAMES.get(typeCode);

            write.addStatement("$N.writeListBegin($T.$L, $L.size())", proto, TTYPE, typeCodeName, nameStack.peek());
            write.beginControlFlow("for ($T $N : $L)", getJavaClassName(tt), item, nameStack.peek());

            scopeLevel++;
            nameStack.push(item);
            tt.accept(this);
            nameStack.pop();
            scopeLevel--;

            write.endControlFlow();
            return null;
        }

        @Override
        public Void visitSet(ThriftType.SetType setType) {
            initCollectionHelpers();
            String tag = "item" + scopeLevel;
            String item = nameAllocator.newName(tag, tag);

            ThriftType tt = setType.elementType().getTrueType();
            byte typeCode = typeCode(tt);
            String typeCodeName = TTYPE_NAMES.get(typeCode);

            write.addStatement("$N.writeSetBegin($T.$L, $L.size())", proto, TTYPE, typeCodeName, nameStack.peek());
            write.beginControlFlow("for ($T $N : $L)", getJavaClassName(tt), item, nameStack.peek());

            scopeLevel++;
            nameStack.push(item);
            tt.accept(this);
            nameStack.pop();
            scopeLevel--;

            write.endControlFlow();
            return null;
        }

        @Override
        public Void visitMap(ThriftType.MapType mapType) {
            initCollectionHelpers();
            String entryTag = "entry" + scopeLevel;
            String keyTag = "key" + scopeLevel;
            String valueTag = "value" + scopeLevel;

            String entryName = nameAllocator.newName(entryTag, entryTag);
            String keyName = nameAllocator.newName(keyTag, keyTag);
            String valueName = nameAllocator.newName(valueTag, valueTag);

            ThriftType kt = mapType.keyType().getTrueType();
            ThriftType vt = mapType.valueType().getTrueType();

            write.addStatement(
                    "$N.writeMapBegin($T.$L, $T.$L, $L.size()",
                    proto,
                    TTYPE,
                    TTYPE_NAMES.get(typeCode(kt)),
                    TTYPE,
                    TTYPE_NAMES.get(typeCode(vt)),
                    nameStack.peek());

            TypeName keyTypeName = getJavaClassName(kt);
            TypeName valueTypeName = getJavaClassName(vt);
            TypeName entry = ParameterizedTypeName.get(MAP_ENTRY, keyTypeName, valueTypeName);
            write.beginControlFlow("for ($T $N : $L.entrySet())", entry, entryTag, nameStack.peek());
            write.addStatement("$T $N = $N.getKey()", keyTypeName, keyName, entryName);
            write.addStatement("$T $N = $N.getValue()", valueTypeName, valueName, entryName);

            scopeLevel++;
            nameStack.push(keyName);
            kt.accept(this);
            nameStack.pop();

            nameStack.push(valueName);
            vt.accept(this);
            nameStack.pop();
            scopeLevel--;

            write.endControlFlow();

            return null;
        }

        @Override
        public Void visitUserType(ThriftType userType) {
            write.addStatement("$N.ADAPTER.write($N, $L)", userType.name(), proto, nameStack.peek());
            return null;
        }

        @Override
        public Void visitTypedef(ThriftType.TypedefType typedefType) {
            typedefType.getTrueType().accept(this);
            return null;
        }

        private void initCollectionHelpers() {
            if (nameAllocator == null) {
                nameAllocator = new NameAllocator();
                nameAllocator.newName(proto, proto);
            }
        }
    }

    /**
     * Generates Java code to read a field's value from an open Protocol object.
     *
     * Assumptions:
     * We are inside of {@link Adapter#read(Protocol)}.  Further, we are
     * inside of a single case block for a single field.  There are variables
     * in scope named "protocol" and "builder", representing the connection and
     * the struct builder.
     */
    class GenerateReaderVisitor implements ThriftType.Visitor<Void> {
        private NameAllocator nameAllocator;
        private Deque<String> nameStack = new ArrayDeque<>();
        private MethodSpec.Builder read;
        private Field field;
        private int scope;

        GenerateReaderVisitor(MethodSpec.Builder read, Field field) {
            this.read = read;
            this.field = field;
        }

        public void generate() {
            byte fieldTypeCode = typeCode(field.type());
            if (fieldTypeCode == TType.ENUM) {
                // Enums are I32 on the wire
                fieldTypeCode = TType.I32;
            }
            String codeName = TTYPE_NAMES.get(fieldTypeCode);
            read.beginControlFlow("if (field.typeId == $T.$L)", TTYPE, codeName);

            // something
            nameStack.push("value");
            field.type().getTrueType().accept(this);
            nameStack.pop();

            read.addStatement("builder.$N(value)", field.name());

            read.nextControlFlow("else");
            read.addStatement("$T.skip(protocol, field.typeId)", PROTO_UTIL);
            read.endControlFlow();

        }

        @Override
        public Void visitBool() {
            read.addStatement("$T $N = protocol.readBool()", BOOLEAN, nameStack.peek());
            return null;
        }

        @Override
        public Void visitByte() {
            read.addStatement("$T $N = protocol.readByte()", BYTE, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI16() {
            read.addStatement("$T $N = protocol.readI16()", SHORT, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI32() {
            read.addStatement("$T $N = protocol.readI32()", INTEGER, nameStack.peek());
            return null;
        }

        @Override
        public Void visitI64() {
            read.addStatement("$T $N = protocol.readI64()", LONG, nameStack.peek());
            return null;
        }

        @Override
        public Void visitDouble() {
            read.addStatement("$T $N = protocol.readDouble()", DOUBLE, nameStack.peek());
            return null;
        }

        @Override
        public Void visitString() {
            read.addStatement("$T $N = protocol.readString()", STRING, nameStack.peek());
            return null;
        }

        @Override
        public Void visitBinary() {
            read.addStatement("$T $N = protocol.readBinary()", BYTE_STRING, nameStack.peek());
            return null;
        }

        @Override
        public Void visitVoid() {
            throw new AssertionError("Cannot read void");
        }

        @Override
        public Void visitEnum(ThriftType userType) {
            String target = nameStack.peek();
            TypeName enumType = getJavaClassName(userType);
            read.addStatement("$T $N = $T.fromCode(protocol.readI32())", enumType, target, enumType);
            return null;
        }

        @Override
        public Void visitList(ThriftType.ListType listType) {
            initNameAllocator();

            TypeName elementType = getJavaClassName(listType.elementType().getTrueType());
            TypeName genericListType = ParameterizedTypeName.get(LIST, elementType);
            TypeName listImplType = ParameterizedTypeName.get(listClassName, elementType);

            String listInfo = "listMetadata" + scope;
            String idx = "i" + scope;
            String item = "item" + scope;

            read.addStatement("$T $N = protocol.readListBegin()", LIST_META, listInfo);
            read.addStatement("$T $N = new $T($N.size)", genericListType, nameStack.peek(), listImplType, listInfo);
            read.beginControlFlow("for (int $N = 0; $N < $N.size; ++$N)", idx, idx, listInfo, idx);

            ++scope;
            nameStack.push(item);

            listType.elementType().getTrueType().accept(this);

            nameStack.pop();
            --scope;

            read.addStatement("$N.add($N)", nameStack.peek(), item);
            read.endControlFlow();
            read.addStatement("protocol.readListEnd()");

            return null;
        }

        @Override
        public Void visitSet(ThriftType.SetType setType) {
            initNameAllocator();

            TypeName elementType = getJavaClassName(setType.elementType().getTrueType());
            TypeName genericSetType = ParameterizedTypeName.get(SET, elementType);
            TypeName setImplType = ParameterizedTypeName.get(setClassName, elementType);

            String setInfo = "setMetadata" + scope;
            String idx = "i" + scope;
            String item = "item" + scope;

            read.addStatement("$T $N = protocol.readSetBegin()", SET_META, setInfo);
            read.addStatement("$T $N = new $T($N.size)", genericSetType, nameStack.peek(), setImplType, setInfo);
            read.beginControlFlow("for (int $N = 0; $N < $N.size; ++$N)", idx, idx, setInfo, idx);

            ++scope;
            nameStack.push(item);

            setType.elementType().accept(this);

            nameStack.pop();
            --scope;

            read.addStatement("$N.add($N)", nameStack.peek(), item);
            read.endControlFlow();
            read.addStatement("protocol.readSetEnd()");

            return null;
        }

        @Override
        public Void visitMap(ThriftType.MapType mapType) {
            initNameAllocator();

            TypeName keyType = getJavaClassName(mapType.keyType().getTrueType());
            TypeName valueType = getJavaClassName(mapType.valueType().getTrueType());
            TypeName genericMapType = ParameterizedTypeName.get(MAP, keyType, valueType);
            TypeName mapImplType = ParameterizedTypeName.get(mapClassName, keyType, valueType);

            String mapInfo = "mapMetadata" + scope;
            String idx = "i" + scope;
            String key = "key" + scope;
            String value = "value" + scope;
            ++scope;

            read.addStatement("$T $N = protocol.readMapBegin()", MAP_META, mapInfo);
            read.addStatement("$T $N = new $T($N.size)", genericMapType, nameStack.peek(), mapImplType, mapInfo);
            read.beginControlFlow("for (int $N = 0; $N < $N.size; ++$N)", idx, idx, mapInfo, idx);

            nameStack.push(key);
            mapType.keyType().accept(this);
            nameStack.pop();

            nameStack.push(value);
            mapType.valueType().accept(this);
            nameStack.pop();

            read.addStatement("$N.put($N, $N)", nameStack.peek(), key, value);

            read.endControlFlow();
            read.addStatement("protocol.readMapEnd()");

            --scope;

            return null;
        }

        @Override
        public Void visitUserType(ThriftType userType) {
            TypeName typeName = getJavaClassName(userType);
            read.addStatement("$T $N = $T.ADAPTER.read(protocol)", typeName, nameStack.peek(), typeName);
            return null;
        }

        @Override
        public Void visitTypedef(ThriftType.TypedefType typedefType) {
            // throw AssertionError?
            typedefType.getTrueType().accept(this);
            return null;
        }

        private void initNameAllocator() {
            if (nameAllocator == null) {
                nameAllocator = new NameAllocator();
                nameAllocator.newName("protocol", "protocol");
                nameAllocator.newName("builder", "builder");
                nameAllocator.newName("value", "value");
            }
        }
    }

    /**
     * A Visitor that converts a {@link ThriftType} into a {@link TypeName}.
     */
    private final ThriftType.Visitor<TypeName> typeNameVisitor = new ThriftType.Visitor<TypeName>() {
        @Override
        public TypeName visitBool() {
            return BOOLEAN;
        }

        @Override
        public TypeName visitByte() {
            return BYTE;
        }

        @Override
        public TypeName visitI16() {
            return SHORT;
        }

        @Override
        public TypeName visitI32() {
            return INTEGER;
        }

        @Override
        public TypeName visitI64() {
            return LONG;
        }

        @Override
        public TypeName visitDouble() {
            return DOUBLE;
        }

        @Override
        public TypeName visitString() {
            return STRING;
        }

        @Override
        public TypeName visitBinary() {
            return BYTE_STRING;
        }

        @Override
        public TypeName visitVoid() {
            return VOID;
        }

        @Override
        public TypeName visitEnum(ThriftType userType) {
            return visitUserType(userType);
        }

        @Override
        public TypeName visitList(ThriftType.ListType listType) {
            ThriftType elementType = listType.elementType().getTrueType();
            TypeName elementTypeName = elementType.accept(this);
            return ParameterizedTypeName.get(LIST, elementTypeName);
        }

        @Override
        public TypeName visitSet(ThriftType.SetType setType) {
            ThriftType elementType = setType.elementType().getTrueType();
            TypeName elementTypeName = elementType.accept(this);
            return ParameterizedTypeName.get(SET, elementTypeName);
        }

        @Override
        public TypeName visitMap(ThriftType.MapType mapType) {
            ThriftType keyType = mapType.keyType().getTrueType();
            ThriftType valueType = mapType.valueType().getTrueType();

            TypeName keyTypeName = keyType.accept(this);
            TypeName valueTypeName = valueType.accept(this);
            return ParameterizedTypeName.get(MAP, keyTypeName, valueTypeName);
        }

        @Override
        public TypeName visitUserType(ThriftType userType) {
            String packageName = userType.getNamespace(NamespaceScope.JAVA);
            if (Strings.isNullOrEmpty(packageName)) {
                throw new AssertionError("Missing namespace.  Did you forget to add 'namespace java'?");
            }

            String key = packageName + "##" + userType.name();
            ClassName cn = nameCache.get(key);
            if (cn == null) {
                cn = ClassName.get(packageName, userType.name());
                nameCache.put(key, cn);
            }
            return cn;
        }

        @Override
        public TypeName visitTypedef(ThriftType.TypedefType typedefType) {
            throw new AssertionError("Typedefs should have been resolved");
        }
    };

    /**
     * A Visitor that converts a {@link ThriftType} into a {@link TType}
     * constant value.
     */
    private static final ThriftType.Visitor<Byte> TYPE_CODE_VISITOR = new ThriftType.Visitor<Byte>() {
        @Override
        public Byte visitBool() {
            return TType.BOOL;
        }

        @Override
        public Byte visitByte() {
            return TType.BYTE;
        }

        @Override
        public Byte visitI16() {
            return TType.I16;
        }

        @Override
        public Byte visitI32() {
            return TType.I32;
        }

        @Override
        public Byte visitI64() {
            return TType.I64;
        }

        @Override
        public Byte visitDouble() {
            return TType.DOUBLE;
        }

        @Override
        public Byte visitString() {
            return TType.STRING;
        }

        @Override
        public Byte visitBinary() {
            return TType.STRING;
        }

        @Override
        public Byte visitVoid() {
            return TType.VOID;
        }

        @Override
        public Byte visitEnum(ThriftType userType) {
            return TType.ENUM;
        }

        @Override
        public Byte visitList(ThriftType.ListType listType) {
            return TType.LIST;
        }

        @Override
        public Byte visitSet(ThriftType.SetType setType) {
            return TType.SET;
        }

        @Override
        public Byte visitMap(ThriftType.MapType mapType) {
            return TType.MAP;
        }

        @Override
        public Byte visitUserType(ThriftType userType) {
            return TType.STRUCT;
        }

        @Override
        public Byte visitTypedef(ThriftType.TypedefType typedefType) {
            throw new AssertionError("Typedefs should have been resolved");
        }
    };
}
